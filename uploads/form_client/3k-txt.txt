import tkinter as tk
from tkinter import messagebox
from datetime import datetime
from tkcalendar import DateEntry

class LibraryApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Library Management System")
        self.root.geometry("600x400")
        
        self.books = []
        self.users = []
        self.borrowed_books = []  # To store borrowed books info
        self.report_data = []  # To store report data for returned books

        self.current_book_id = 1  # To keep track of book ID
        self.current_user_id = 1  # To keep track of user ID
        
        # Sidebar Frame
        self.sidebar = tk.Frame(root, bg="#f0f0f0", width=150, height=400)
        self.sidebar.pack(side="left", fill="y")
        
        # Sidebar Buttons
        self.books_button = tk.Button(self.sidebar, text="Books", width=15, command=self.show_books)
        self.books_button.pack(pady=10)
        self.users_button = tk.Button(self.sidebar, text="Users", width=15, command=self.show_users)
        self.users_button.pack(pady=10)
        self.return_borrow_button = tk.Button(self.sidebar, text="Return/Borrow", width=15, command=self.show_borrow_return)
        self.return_borrow_button.pack(pady=10)
        self.reports_button = tk.Button(self.sidebar, text="Reports", width=15, command=self.show_reports)
        self.reports_button.pack(pady=10)


        # Content Frame for Books, Users, and Borrow/Return sections
        self.content_frame = tk.Frame(root)
        self.content_frame.pack(side="right", fill="both", expand=True)

        # Initialize with Books section
        self.show_books()

    def show_reports(self):
        # Clear existing content in the content frame
        for widget in self.content_frame.winfo_children():
            widget.destroy()

        # Reports Table
        self.report_table_frame = tk.Frame(self.content_frame)
        self.report_table_frame.grid(row=0, columnspan=2, pady=20)
        self.create_reports_table()


    def calculate_penalty(self, return_date):
        # Get today's date
        today = datetime.today().date()
        
        # If the book is not returned yet, assume penalty for overdue books
        if return_date == "Not Returned":
            return 0
        
        # Parse return_date into a datetime object
        return_date_obj = datetime.strptime(return_date, "%Y-%m-%d").date()
        
        # Calculate the difference in days between today and the return date
        overdue_days = (today - return_date_obj).days
        
        if overdue_days > 0:
            # Penalty: Assume $1 per day overdue
            return overdue_days
        else:
            return 0  # No penalty if the book is returned on time or in advance
        
    def create_reports_table(self):
        # Clear existing table content
        for widget in self.report_table_frame.winfo_children():
            widget.destroy()

        # Table Headers for Reports
        headers = ["Student ID", "Full Name", "Contact Number", "Book Name", "Book Author", "Borrowed Date", "Expected Return Date", "Date Returned", "Penalty"]
        for i, header in enumerate(headers):
            label = tk.Label(self.report_table_frame, text=header, font=("Arial", 10, "bold"))
            label.grid(row=0, column=i, padx=10, pady=5)

        # Table Data for Reports
        for row_index, report in enumerate(self.report_data, start=1):
            tk.Label(self.report_table_frame, text=report['user_id']).grid(row=row_index, column=0, padx=10, pady=5)
            tk.Label(self.report_table_frame, text=report['full_name']).grid(row=row_index, column=1, padx=10, pady=5)
            tk.Label(self.report_table_frame, text=report['contact_number']).grid(row=row_index, column=2, padx=10, pady=5)
            tk.Label(self.report_table_frame, text=report['book']).grid(row=row_index, column=3, padx=10, pady=5)
            tk.Label(self.report_table_frame, text=report['author']).grid(row=row_index, column=4, padx=10, pady=5)
            tk.Label(self.report_table_frame, text=report['borrow_date']).grid(row=row_index, column=5, padx=10, pady=5)
            tk.Label(self.report_table_frame, text=report['return_date']).grid(row=row_index, column=6, padx=10, pady=5)
            tk.Label(self.report_table_frame, text=report['date_returned']).grid(row=row_index, column=7, padx=10, pady=5)
            tk.Label(self.report_table_frame, text=report['penalty']).grid(row=row_index, column=8, padx=10, pady=5)


    def show_books(self):
        # Clear existing content in the content frame
        for widget in self.content_frame.winfo_children():
            widget.destroy()

        # Book Form
        self.book_name_label = tk.Label(self.content_frame, text="Book Name:")
        self.book_name_label.grid(row=0, column=0, padx=10, pady=10)
        self.book_name_entry = tk.Entry(self.content_frame)
        self.book_name_entry.grid(row=0, column=1, padx=10, pady=10)

        self.book_author_label = tk.Label(self.content_frame, text="Book Author:")
        self.book_author_label.grid(row=1, column=0, padx=10, pady=10)
        self.book_author_entry = tk.Entry(self.content_frame)
        self.book_author_entry.grid(row=1, column=1, padx=10, pady=10)

        self.add_button = tk.Button(self.content_frame, text="Add Book", command=self.add_book)
        self.add_button.grid(row=2, columnspan=2, pady=10)

        # Book Table
        self.book_table_frame = tk.Frame(self.content_frame)
        self.book_table_frame.grid(row=3, columnspan=2, pady=20)
        self.create_book_table()

    def show_users(self):
        # Clear existing content in the content frame
        for widget in self.content_frame.winfo_children():
            widget.destroy()

        # User Form
        self.student_number_label = tk.Label(self.content_frame, text="Student Number:")
        self.student_number_label.grid(row=0, column=0, padx=10, pady=10)
        self.student_number_entry = tk.Entry(self.content_frame)
        self.student_number_entry.grid(row=0, column=1, padx=10, pady=10)

        self.student_name_label = tk.Label(self.content_frame, text="Full Name:")
        self.student_name_label.grid(row=1, column=0, padx=10, pady=10)
        self.student_name_entry = tk.Entry(self.content_frame)
        self.student_name_entry.grid(row=1, column=1, padx=10, pady=10)

        self.contact_number_label = tk.Label(self.content_frame, text="Contact Number:")
        self.contact_number_label.grid(row=2, column=0, padx=10, pady=10)
        self.contact_number_entry = tk.Entry(self.content_frame)
        self.contact_number_entry.grid(row=2, column=1, padx=10, pady=10)

        self.add_user_button = tk.Button(self.content_frame, text="Add User", command=self.add_user)
        self.add_user_button.grid(row=3, columnspan=2, pady=10)

        # User Table
        self.user_table_frame = tk.Frame(self.content_frame)
        self.user_table_frame.grid(row=4, columnspan=2, pady=20)
        self.create_user_table()

    def show_borrow_return(self):
        # Clear existing content in the content frame
        for widget in self.content_frame.winfo_children():
            widget.destroy()

        # Create a StringVar for the selected user and book
        self.selected_user = tk.StringVar()
        self.selected_book = tk.StringVar()

        # Borrow/Return Form
        self.select_user_label = tk.Label(self.content_frame, text="Select User:")
        self.select_user_label.grid(row=0, column=0, padx=10, pady=10)

        # Use OptionMenu with the StringVar for the selected user
        self.user_dropdown = tk.OptionMenu(self.content_frame, self.selected_user, *[user['full_name'] for user in self.users])
        self.user_dropdown.grid(row=0, column=1, padx=10, pady=10)

        self.select_book_label = tk.Label(self.content_frame, text="Select Book:")
        self.select_book_label.grid(row=1, column=0, padx=10, pady=10)

        # Use OptionMenu with the StringVar for the selected book
        self.book_dropdown = tk.OptionMenu(self.content_frame, self.selected_book, *[book['name'] for book in self.books])
        self.book_dropdown.grid(row=1, column=1, padx=10, pady=10)

        self.borrow_date_label = tk.Label(self.content_frame, text="Borrow Date:")
        self.borrow_date_label.grid(row=2, column=0, padx=10, pady=10)

        # Create a DateEntry widget for Borrow Date
        self.borrow_date_entry = DateEntry(self.content_frame, date_pattern="yyyy-mm-dd")
        self.borrow_date_entry.grid(row=2, column=1, padx=10, pady=10)

        self.return_date_label = tk.Label(self.content_frame, text="Expected Return Date:")
        self.return_date_label.grid(row=3, column=0, padx=10, pady=10)

        # Create a DateEntry widget for Expected Return Date
        self.return_date_entry = DateEntry(self.content_frame, date_pattern="yyyy-mm-dd")
        self.return_date_entry.grid(row=3, column=1, padx=10, pady=10)

        self.borrow_button = tk.Button(self.content_frame, text="Borrow Book", command=self.borrow_book)
        self.borrow_button.grid(row=4, columnspan=2, pady=10)

        # Borrowed Books Table
        self.borrowed_books_frame = tk.Frame(self.content_frame)
        self.borrowed_books_frame.grid(row=5, columnspan=2, pady=20)
        self.create_borrowed_books_table()
    

    def create_book_table(self):
        # Clear existing table content
        for widget in self.book_table_frame.winfo_children():
            widget.destroy()

        # Table Headers for Books
        headers = ["ID", "Book Name", "Book Author", "Action"]
        for i, header in enumerate(headers):
            label = tk.Label(self.book_table_frame, text=header, font=("Arial", 10, "bold"))
            label.grid(row=0, column=i, padx=10, pady=5)

        # Table Data for Books
        for row_index, book in enumerate(self.books, start=1):
            tk.Label(self.book_table_frame, text=book['id']).grid(row=row_index, column=0, padx=10, pady=5)
            tk.Label(self.book_table_frame, text=book['name']).grid(row=row_index, column=1, padx=10, pady=5)
            tk.Label(self.book_table_frame, text=book['author']).grid(row=row_index, column=2, padx=10, pady=5)

            update_button = tk.Button(self.book_table_frame, text="Update", command=lambda idx=row_index-1: self.update_book(idx))
            update_button.grid(row=row_index, column=3, padx=5, pady=5)

            delete_button = tk.Button(self.book_table_frame, text="Delete", command=lambda idx=row_index-1: self.delete_book(idx))
            delete_button.grid(row=row_index, column=4, padx=5, pady=5)

    def create_user_table(self):
        # Clear existing table content
        for widget in self.user_table_frame.winfo_children():
            widget.destroy()

        # Table Headers for Users
        headers = ["ID", "Student Number", "Full Name", "Contact Number", "Action"]
        for i, header in enumerate(headers):
            label = tk.Label(self.user_table_frame, text=header, font=("Arial", 10, "bold"))
            label.grid(row=0, column=i, padx=10, pady=5)

        # Table Data for Users
        for row_index, user in enumerate(self.users, start=1):
            tk.Label(self.user_table_frame, text=user['id']).grid(row=row_index, column=0, padx=10, pady=5)
            tk.Label(self.user_table_frame, text=user['student_number']).grid(row=row_index, column=1, padx=10, pady=5)
            tk.Label(self.user_table_frame, text=user['full_name']).grid(row=row_index, column=2, padx=10, pady=5)
            tk.Label(self.user_table_frame, text=user['contact_number']).grid(row=row_index, column=3, padx=10, pady=5)

            update_button = tk.Button(self.user_table_frame, text="Update", command=lambda idx=row_index-1: self.update_user(idx))
            update_button.grid(row=row_index, column=4, padx=5, pady=5)

            delete_button = tk.Button(self.user_table_frame, text="Delete", command=lambda idx=row_index-1: self.delete_user(idx))
            delete_button.grid(row=row_index, column=5, padx=5, pady=5)

    def create_borrowed_books_table(self):
    # Clear existing table content
        for widget in self.borrowed_books_frame.winfo_children():
            widget.destroy()

        # Table Headers for Borrowed Books
        headers = ["Student ID", "Full Name", "Contact Number", "Book Name", "Book Author", "Borrowed Date", "Expected Return Date", "Action"]
        for i, header in enumerate(headers):
            label = tk.Label(self.borrowed_books_frame, text=header, font=("Arial", 10, "bold"))
            label.grid(row=0, column=i, padx=10, pady=5)

        # Table Data for Borrowed Books
        for row_index, record in enumerate(self.borrowed_books, start=1):
            # Extract the book details based on the book name
            book_details = next(book for book in self.books if book['name'] == record['book'])
            
            # Display the borrowed book information
            tk.Label(self.borrowed_books_frame, text=record['user_id']).grid(row=row_index, column=0, padx=10, pady=5)
            tk.Label(self.borrowed_books_frame, text=record['full_name']).grid(row=row_index, column=1, padx=10, pady=5)
            tk.Label(self.borrowed_books_frame, text=record['contact_number']).grid(row=row_index, column=2, padx=10, pady=5)
            tk.Label(self.borrowed_books_frame, text=record['book']).grid(row=row_index, column=3, padx=10, pady=5)
            tk.Label(self.borrowed_books_frame, text=book_details['author']).grid(row=row_index, column=4, padx=10, pady=5)
            tk.Label(self.borrowed_books_frame, text=record['borrow_date']).grid(row=row_index, column=5, padx=10, pady=5)
            tk.Label(self.borrowed_books_frame, text=record['return_date']).grid(row=row_index, column=6, padx=10, pady=5)

            return_button = tk.Button(self.borrowed_books_frame, text="Return", command=lambda idx=row_index-1: self.return_book(idx))
            return_button.grid(row=row_index, column=7, padx=5, pady=5)


    def borrow_book(self):
        user_name = self.selected_user.get()  # Get selected user
        book_name = self.selected_book.get()  # Get selected book
        borrow_date = self.borrow_date_entry.get()  # Get selected borrow date
        return_date = self.return_date_entry.get()  # Get selected Expected Return Date

        if user_name and book_name and borrow_date and return_date:
            # Find user details by matching the full_name
            user_details = next(user for user in self.users if user['full_name'] == user_name)

            borrowed_book = {
                'user_id': user_details['id'],
                'full_name': user_details['full_name'],
                'contact_number': user_details['contact_number'],
                'book': book_name,
                'borrow_date': borrow_date,
                'return_date': return_date
            }

            self.borrowed_books.append(borrowed_book)
            self.create_borrowed_books_table()
        else:
            messagebox.showwarning("Input Error", "Please fill in all fields.")

    def return_book(self, idx):
        # Create a popup window for the return date selection
        return_window = tk.Toplevel(self.root)
        return_window.title("Return Book")
        return_window.geometry("300x200")
        
        # Get the borrowed book record
        borrowed_book = self.borrowed_books[idx]
        
        # Label for return date
        return_date_label = tk.Label(return_window, text="Select Actual Return Date:")
        return_date_label.pack(pady=10)
        
        # Date picker for actual return date
        return_date_picker = DateEntry(return_window, date_pattern="yyyy-mm-dd")
        return_date_picker.pack(pady=10)
        
        # Button to confirm the return and update the report
        confirm_return_button = tk.Button(return_window, text="Return Book", command=lambda: self.confirm_return(idx, borrowed_book, return_date_picker.get_date(), return_window))
        confirm_return_button.pack(pady=10)

    def confirm_return(self, idx, borrowed_book, return_date, return_window):
        # Close the return window
        return_window.destroy()
        
        # Get the expected return date and current return date
        expected_return_date = datetime.strptime(borrowed_book['return_date'], "%Y-%m-%d").date()
        date_returned = return_date  # Use the selected return date
        
        # Calculate the penalty if the book is returned late
        penalty_days = (date_returned - expected_return_date).days
        penalty = 0  # Default penalty
        
        if penalty_days > 0:
            # Assuming $10 per day penalty
            penalty = penalty_days * 10
        
        # Add the returned book information to the report
        report_entry = {
            'user_id': borrowed_book['user_id'],
            'full_name': borrowed_book['full_name'],
            'contact_number': borrowed_book['contact_number'],
            'book': borrowed_book['book'],
            'author': next(book for book in self.books if book['name'] == borrowed_book['book'])['author'],
            'borrow_date': borrowed_book['borrow_date'],
            'return_date': borrowed_book['return_date'],
            'date_returned': date_returned.strftime("%Y-%m-%d"),  # Use the selected return date
            'penalty': penalty  # Set the calculated penalty
        }
        
        self.report_data.append(report_entry)  # Add to report data
        
        # Remove from borrowed books
        del self.borrowed_books[idx]
        
        self.create_borrowed_books_table()
        self.create_reports_table()  # Refresh the reports table


    def add_book(self):
        book_name = self.book_name_entry.get()
        book_author = self.book_author_entry.get()

        if book_name and book_author:
            self.books.append({'id': self.current_book_id, 'name': book_name, 'author': book_author})
            self.current_book_id += 1
            self.book_name_entry.delete(0, tk.END)
            self.book_author_entry.delete(0, tk.END)
            self.create_book_table()
        else:
            messagebox.showwarning("Input Error", "Please enter both Book Name and Book Author.")

    def update_book(self, idx):
        book = self.books[idx]
        self.book_name_entry.delete(0, tk.END)
        self.book_name_entry.insert(0, book['name'])
        self.book_author_entry.delete(0, tk.END)
        self.book_author_entry.insert(0, book['author'])
        self.add_button.config(text="Update Book", command=lambda: self.save_update_book(idx))

    def save_update_book(self, idx):
        updated_name = self.book_name_entry.get()
        updated_author = self.book_author_entry.get()

        if updated_name and updated_author:
            self.books[idx] = {'id': self.books[idx]['id'], 'name': updated_name, 'author': updated_author}
            self.book_name_entry.delete(0, tk.END)
            self.book_author_entry.delete(0, tk.END)
            self.add_button.config(text="Add Book", command=self.add_book)
            self.create_book_table()
        else:
            messagebox.showwarning("Input Error", "Please enter both Book Name and Book Author.")

    def delete_book(self, idx):
        confirmation = messagebox.askyesno("Delete Book", "Are you sure you want to delete this book?")
        if confirmation:
            del self.books[idx]
            self.create_book_table()

    def add_user(self):
        student_number = self.student_number_entry.get()
        full_name = self.student_name_entry.get()
        contact_number = self.contact_number_entry.get()

        if student_number and full_name and contact_number:
            self.users.append({'id': self.current_user_id, 'student_number': student_number, 'full_name': full_name, 'contact_number': contact_number})
            self.current_user_id += 1
            self.student_number_entry.delete(0, tk.END)
            self.student_name_entry.delete(0, tk.END)
            self.contact_number_entry.delete(0, tk.END)
            self.create_user_table()
        else:
            messagebox.showwarning("Input Error", "Please enter Student Number, Full Name, and Contact Number.")

    def update_user(self, idx):
        user = self.users[idx]
        self.student_number_entry.delete(0, tk.END)
        self.student_number_entry.insert(0, user['student_number'])
        self.student_name_entry.delete(0, tk.END)
        self.student_name_entry.insert(0, user['full_name'])
        self.contact_number_entry.delete(0, tk.END)
        self.contact_number_entry.insert(0, user['contact_number'])
        self.add_user_button.config(text="Update User", command=lambda: self.save_update_user(idx))

    def save_update_user(self, idx):
        updated_number = self.student_number_entry.get()
        updated_name = self.student_name_entry.get()
        updated_contact = self.contact_number_entry.get()

        if updated_number and updated_name and updated_contact:
            self.users[idx] = {'id': self.users[idx]['id'], 'student_number': updated_number, 'full_name': updated_name, 'contact_number': updated_contact}
            self.student_number_entry.delete(0, tk.END)
            self.student_name_entry.delete(0, tk.END)
            self.contact_number_entry.delete(0, tk.END)
            self.add_user_button.config(text="Add User", command=self.add_user)
            self.create_user_table()
        else:
            messagebox.showwarning("Input Error", "Please enter Student Number, Full Name, and Contact Number.")

    def delete_user(self, idx):
        confirmation = messagebox.askyesno("Delete User", "Are you sure you want to delete this user?")
        if confirmation:
            del self.users[idx]
            self.create_user_table()


if __name__ == "__main__":
    root = tk.Tk()
    app = LibraryApp(root)
    root.mainloop()
